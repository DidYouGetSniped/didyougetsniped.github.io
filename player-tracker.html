<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>War Brokers Player Count Tracker</title>
    <link rel="stylesheet" href="playercounttracker.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.45/moment-timezone-with-data.min.js"></script>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XGNQRLJMGK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
    
  gtag('config', 'G-XGNQRLJMGK');
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const style = document.createElement('style');
  style.innerHTML = "* { cursor: url('wb kill.png') 16 16, auto !important; }";
  document.head.appendChild(style);
});
</script>

<body>
    <div class="header">
        <div class="header-content">
            <h1>WAR BROKERS</h1>
            <div class="header-subtitle">PLAYER COUNT ANALYTICS</div>
        </div>
        <a href="./" class="back-link">‚Üê BACK TO HOME</a>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>‚öô CONTROLS</h2>
            </div>

            <div class="setting-group">
                <label>AUTO REFRESH</label>
                <label class="checkbox-label">
                    <input type="checkbox" id="autoRefresh" checked>
                    <span>Check every 90sec</span>
                </label>
            </div>

            <div class="setting-group">
                <label>CHART TYPE</label>
                <select id="chartType">
                    <option value="line">Line Chart</option>
                    <option value="bar">Bar Chart</option>
                </select>
            </div>

            <div class="setting-group">
                <label>TIME RANGE</label>
                <select id="timeRange">
                    <option value="12">Last 12 Hours</option>
                    <option value="24">Last 24 Hours</option>
                    <option value="48">Last 48 Hours</option>
                    <option value="168">Last 7 Days</option>
                    <option value="720">Last 30 Days</option>
                    <option value="all">All Data</option>
                    <option value="custom">Custom Range</option>
                </select>
            </div>

            <div class="setting-group" id="customRangeGroup" style="display: none;">
                <label>START DATE & TIME</label>
                <input type="datetime-local" id="customStartDate">
                
                <label style="margin-top: 12px;">DURATION (HOURS)</label>
                <input type="number" id="customDuration" min="1" max="8760" value="48" placeholder="Hours">
            </div>

            <div class="setting-group">
                <label>DATA POINTS</label>
                <select id="dataDensity">
                    <option value="auto">Smart (Auto)</option>
                    <option value="all">All Points</option>
                    <option value="hourly">Hourly</option>
                    <option value="every3">Every 3 Hours</option>
                    <option value="every6">Every 6 Hours</option>
                    <option value="daily">Daily</option>
                </select>
            </div>

            <div class="setting-group">
                <label>GRID LINES</label>
                <label class="checkbox-label">
                    <input type="checkbox" id="showGrid" checked>
                    <span>Show grid</span>
                </label>
            </div>

            <div class="setting-group">
                <label>TIMEZONE</label>
                <select id="timezone">
                    <option value="local">Local Time</option>
                    <option value="UTC">UTC</option>
                    <option value="America/New_York">Eastern (ET)</option>
                    <option value="America/Chicago">Central (CT)</option>
                    <option value="America/Denver">Mountain (MT)</option>
                    <option value="America/Los_Angeles">Pacific (PT)</option>
                    <option value="Europe/London">London (GMT)</option>
                    <option value="Europe/Paris">Paris (CET)</option>
                    <option value="Asia/Tokyo">Tokyo (JST)</option>
                    <option value="Asia/Shanghai">Shanghai (CST)</option>
                    <option value="Australia/Sydney">Sydney (AEDT)</option>
                    <option value="Asia/Dubai">Dubai (GST)</option>
                </select>
            </div>

            <div class="setting-group">
                <label>TIME FORMAT</label>
                <label class="checkbox-label">
                    <input type="checkbox" id="use24Hour" checked>
                    <span>24-hour format</span>
                </label>
            </div>

            <div class="button-group">
                <button class="btn btn-primary" id="refreshBtn">
                    <span class="btn-icon">‚Üª</span>
                    <span>REFRESH NOW</span>
                </button>
                <button class="btn btn-success" id="exportBtn">
                    <span class="btn-icon">üì•</span>
                    <span>EXPORT CSV</span>
                </button>
                <button class="btn btn-success" id="exportImageBtn">
                    <span class="btn-icon">üñºÔ∏è</span>
                    <span>EXPORT PNG</span>
                </button>
            </div>

            <div class="status" id="status">
                <span class="status-dot active"></span>
                <span id="statusText">Loading data...</span>
            </div>
        </div>

        <div class="main">
            <div class="stats-grid">
                <div class="stat-box stat-current">
                    <div class="stat-icon">üë•</div>
                    <div class="stat-content">
                        <div class="stat-label">CURRENT</div>
                        <div class="stat-value" id="currentPlayers">-</div>
                    </div>
                </div>
                <div class="stat-box stat-peak">
                    <div class="stat-icon">üìà</div>
                    <div class="stat-content">
                        <div class="stat-label">PEAK</div>
                        <div class="stat-value" id="peakPlayers">-</div>
                    </div>
                </div>
                <div class="stat-box stat-min">
                    <div class="stat-icon">üìâ</div>
                    <div class="stat-content">
                        <div class="stat-label">MINIMUM</div>
                        <div class="stat-value" id="minPlayers">-</div>
                    </div>
                </div>
                <div class="stat-box stat-avg">
                    <div class="stat-icon">üìä</div>
                    <div class="stat-content">
                        <div class="stat-label">AVERAGE</div>
                        <div class="stat-value" id="avgPlayers">-</div>
                    </div>
                </div>
            </div>

            <div id="dateDisplay" class="date-display" style="display: none;"></div>

            <div class="chart-container" id="chartWrapper">
                <canvas id="playerChart"></canvas>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color"></div>
                    <span>PLAYER COUNT</span>
                </div>
                <div class="legend-divider">|</div>
                <div class="legend-item">
                    <span id="dataPoints">0 data points</span>
                </div>
                <div class="legend-divider">|</div>
                <div class="legend-item">
                    <span id="lastUpdate">Last updated: Never</span>
                </div>
            </div>
        </div>
    </div>

    <script>
    const autoRefreshCheckbox = document.getElementById('autoRefresh');
    const chartTypeSelect = document.getElementById('chartType');
    const timeRangeSelect = document.getElementById('timeRange');
    const dataDensitySelect = document.getElementById('dataDensity');
    const showGridCheckbox = document.getElementById('showGrid');
    const customRangeGroup = document.getElementById('customRangeGroup');
    const customStartDate = document.getElementById('customStartDate');
    const customDuration = document.getElementById('customDuration');
    const refreshBtn = document.getElementById('refreshBtn');
    const exportBtn = document.getElementById('exportBtn');
    const exportImageBtn = document.getElementById('exportImageBtn');
    const statusEl = document.getElementById('status');
    const statusText = document.getElementById('statusText');
    const currentPlayersEl = document.getElementById('currentPlayers');
    const peakPlayersEl = document.getElementById('peakPlayers');
    const minPlayersEl = document.getElementById('minPlayers');
    const avgPlayersEl = document.getElementById('avgPlayers');
    const dataPointsEl = document.getElementById('dataPoints');
    const lastUpdateEl = document.getElementById('lastUpdate');
    const chartWrapper = document.getElementById('chartWrapper');
    const dateDisplay = document.getElementById('dateDisplay');
    const timezoneSelect = document.getElementById('timezone');
    const use24HourCheckbox = document.getElementById('use24Hour');
    const ctx = document.getElementById('playerChart').getContext('2d');

    let chart = null;
    let trackerData = null;
    let trackerIndex = null;
    let latestWindowStartMs = null;
    let refreshInterval = null;
    const monthDataCache = new Map();
    const TRACKER_BASE_PATH = './playercountinfo';

    // Load all preferences from localStorage (with defaults)
    const savedPrefs = localStorage.getItem('playerTrackerPrefs');
    const preferences = savedPrefs ? JSON.parse(savedPrefs) : {
        chartType: 'line',
        timeRange: '24',
        dataDensity: 'auto',
        showGrid: true,
        autoRefresh: true,
        timezone: 'local',
        use24Hour: true,
        customStartDate: '',
        customDuration: 48
    };

    // Apply loaded prefs to UI elements
    chartTypeSelect.value = preferences.chartType;
    timeRangeSelect.value = preferences.timeRange;
    dataDensitySelect.value = preferences.dataDensity || 'auto';
    showGridCheckbox.checked = preferences.showGrid;
    autoRefreshCheckbox.checked = preferences.autoRefresh;
    timezoneSelect.value = preferences.timezone;
    use24HourCheckbox.checked = preferences.use24Hour;
    customStartDate.value = preferences.customStartDate || '';
    customDuration.value = preferences.customDuration || 48;
    
    // Show custom range group if custom is selected
    if (preferences.timeRange === 'custom') {
        customRangeGroup.style.display = 'block';
    }

    function savePreferences() {
        localStorage.setItem('playerTrackerPrefs', JSON.stringify(preferences));
    }

    function formatTimestamp(timestamp) {
        let m = moment(timestamp);
        
        if (timezoneSelect.value !== 'local') {
            m = m.tz(timezoneSelect.value);
        }
        
        const format = use24HourCheckbox.checked ? 'HH:mm' : 'hh:mm A';
        return m.format(format);
    }

    function toMonthKey(date) {
        const year = date.getUTCFullYear();
        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
        return `${year}-${month}`;
    }

    function monthKeysBetween(startDate, endDate) {
        const start = new Date(Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), 1));
        const end = new Date(Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), 1));
        const keys = [];
        const cursor = new Date(start.getTime());

        while (cursor <= end) {
            keys.push(toMonthKey(cursor));
            cursor.setUTCMonth(cursor.getUTCMonth() + 1);
        }
        return keys;
    }

    function dedupeByTimestamp(points) {
        const seen = new Set();
        const deduped = [];
        for (const point of points) {
            if (seen.has(point.timestamp)) continue;
            seen.add(point.timestamp);
            deduped.push(point);
        }
        return deduped;
    }

    function getRequestedRangeBounds() {
        const now = new Date();
        const range = timeRangeSelect.value;

        if (range === 'all') {
            return { start: null, end: now };
        }

        if (range === 'custom') {
            const duration = parseInt(customDuration.value, 10) || 48;
            if (!customStartDate.value) {
                return {
                    start: new Date(now.getTime() - duration * 60 * 60 * 1000),
                    end: now
                };
            }
            const start = new Date(customStartDate.value);
            const end = new Date(start.getTime() + duration * 60 * 60 * 1000);
            return { start, end };
        }

        const hours = parseInt(range, 10) || 24;
        return {
            start: new Date(now.getTime() - hours * 60 * 60 * 1000),
            end: now
        };
    }

    async function fetchJson(path) {
        const response = await fetch(`${path}?t=${Date.now()}`);
        if (!response.ok) throw new Error(`Failed to load ${path}`);
        return response.json();
    }

    async function loadMonthData(monthKey) {
        if (monthDataCache.has(monthKey)) {
            return monthDataCache.get(monthKey);
        }

        try {
            const monthPayload = await fetchJson(`${TRACKER_BASE_PATH}/player-tracker-data/${monthKey}.json`);
            const points = Array.isArray(monthPayload.data) ? monthPayload.data : [];
            monthDataCache.set(monthKey, points);
            return points;
        } catch (error) {
            console.warn(`Could not load month ${monthKey}:`, error);
            monthDataCache.set(monthKey, []);
            return [];
        }
    }

    async function ensureDataForCurrentRange() {
        if (!trackerData || !trackerIndex || !Array.isArray(trackerIndex.months) || trackerIndex.months.length === 0) {
            return;
        }

        const { start, end } = getRequestedRangeBounds();
        let requiredMonths = [];

        if (!start) {
            requiredMonths = trackerIndex.months.map(m => m.month);
        } else if (latestWindowStartMs === null || start.getTime() < latestWindowStartMs) {
            requiredMonths = monthKeysBetween(start, end || new Date());
        } else {
            return;
        }

        if (requiredMonths.length === 0) return;

        const availableMonths = new Set(trackerIndex.months.map(m => m.month));
        requiredMonths = requiredMonths.filter(month => availableMonths.has(month));
        if (requiredMonths.length === 0) return;

        const monthDataSets = await Promise.all(requiredMonths.map(loadMonthData));
        const merged = monthDataSets.flat().sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        trackerData.data = dedupeByTimestamp(merged);
    }

    async function refreshView() {
        await ensureDataForCurrentRange();
        updateChart();
        updateStats();
    }

    async function loadTrackerData() {
        try {
            try {
                trackerIndex = await fetchJson(`${TRACKER_BASE_PATH}/player-tracker-index.json`);
            } catch {
                trackerIndex = null;
            }

            if (trackerIndex) {
                const latest = await fetchJson(`${TRACKER_BASE_PATH}/player-tracker-latest.json`);
                trackerData = {
                    lastUpdated: trackerIndex.lastUpdated || latest.lastUpdated,
                    currentPlayers: trackerIndex.currentPlayers ?? latest.currentPlayers,
                    dataPoints: trackerIndex.totalDataPoints ?? latest.dataPoints,
                    data: Array.isArray(latest.data) ? latest.data : []
                };
                latestWindowStartMs = trackerData.data.length > 0 ? new Date(trackerData.data[0].timestamp).getTime() : null;
            } else {
                try {
                    const legacy = await fetchJson(`${TRACKER_BASE_PATH}/player-tracker-data.json`);
                    trackerData = legacy;
                } catch {
                    trackerData = await fetchJson('./player-tracker-data.json');
                }
                latestWindowStartMs = trackerData.data && trackerData.data.length > 0
                    ? new Date(trackerData.data[0].timestamp).getTime()
                    : null;
            }

            updateStatus(true, `Last updated: ${new Date(trackerData.lastUpdated).toLocaleTimeString()}`);
            await refreshView();
        } catch (error) {
            console.error('Error loading tracker data:', error);
            updateStatus(false, 'Error loading data - file may not exist yet');
        }
    }

    function updateStatus(success, message) {
        const dot = statusEl.querySelector('.status-dot');
        if (success) {
            statusEl.classList.add('active');
            statusEl.classList.remove('error');
            dot.classList.add('active');
            dot.classList.remove('error');
        } else {
            statusEl.classList.add('error');
            statusEl.classList.remove('active');
            dot.classList.remove('active');
            dot.classList.add('error');
        }
        statusText.textContent = message;
    }

    function updateStats() {
        if (!trackerData || !trackerData.data || trackerData.data.length === 0) return;

        const filtered = getFilteredData();
        if (filtered.length === 0) return;

        const players = filtered.map(d => d.players);
        const current = players[players.length - 1];
        const peak = Math.max(...players);
        const min = Math.min(...players);
        const avg = (players.reduce((a, b) => a + b, 0) / players.length).toFixed(0);

        currentPlayersEl.textContent = current.toLocaleString();
        peakPlayersEl.textContent = peak.toLocaleString();
        minPlayersEl.textContent = min.toLocaleString();
        avgPlayersEl.textContent = avg.toLocaleString();
        dataPointsEl.textContent = `${filtered.length} data point${filtered.length !== 1 ? 's' : ''}`;
        lastUpdateEl.textContent = `Last updated: ${new Date(trackerData.lastUpdated).toLocaleTimeString()}`;
    }

    function getFilteredData() {
        if (!trackerData || !trackerData.data) return [];
        
        const range = timeRangeSelect.value;
        let filtered;
        
        if (range === 'custom') {
            // Custom date range logic
            const startDateValue = customStartDate.value;
            const duration = parseInt(customDuration.value) || 48;
            
            if (!startDateValue) {
                // If no start date specified, default to current time - duration
                const cutoffTime = new Date(Date.now() - duration * 60 * 60 * 1000);
                filtered = trackerData.data.filter(d => new Date(d.timestamp) > cutoffTime);
            } else {
                // Parse the start date and calculate end date
                const startTime = new Date(startDateValue);
                const endTime = new Date(startTime.getTime() + duration * 60 * 60 * 1000);
                
                filtered = trackerData.data.filter(d => {
                    const dataTime = new Date(d.timestamp);
                    return dataTime >= startTime && dataTime <= endTime;
                });
            }
        } else if (range === 'all') {
            filtered = trackerData.data;
        } else {
            // Standard time ranges from current time
            const hours = parseInt(range);
            const cutoffTime = new Date(Date.now() - hours * 60 * 60 * 1000);
            filtered = trackerData.data.filter(d => new Date(d.timestamp) > cutoffTime);
        }

        // Apply smart data density filtering
        const density = dataDensitySelect.value;
        
        if (density === 'auto') {
            // Smart algorithm: adjust based on total points and time range
            const totalPoints = filtered.length;
            if (totalPoints > 200) {
                // For large datasets, show every 6th point
                filtered = filtered.filter((_, i) => i % 6 === 0);
            } else if (totalPoints > 100) {
                // For medium datasets, show every 3rd point
                filtered = filtered.filter((_, i) => i % 3 === 0);
            }
            // For small datasets (< 100 points), show all
        } else if (density === 'hourly') {
            // Show ~1 point per hour (2 data points per hour at 30min intervals)
            filtered = filtered.filter((_, i) => i % 2 === 0);
        } else if (density === 'every3') {
            // Show ~1 point every 3 hours (6 data points)
            filtered = filtered.filter((_, i) => i % 6 === 0);
        } else if (density === 'every6') {
            // Show ~1 point every 6 hours (12 data points)
            filtered = filtered.filter((_, i) => i % 12 === 0);
        } else if (density === 'daily') {
            // Show ~1 point per day (48 data points)
            filtered = filtered.filter((_, i) => i % 48 === 0);
        }
        // 'all' shows all points

        return filtered;
    }

    function updateChart() {
        const filtered = getFilteredData();
        if (filtered.length === 0) {
            if (chart) chart.destroy();
            dateDisplay.style.display = 'none';
            return;
        }

        // Get first and last dates based on selected timezone
        let firstDate = null;
        let lastDate = null;
        
        if (filtered.length > 0) {
            let mFirst = moment(filtered[0].timestamp);
            let mLast = moment(filtered[filtered.length - 1].timestamp);
            
            // Apply the selected timezone
            if (timezoneSelect.value !== 'local') {
                mFirst = mFirst.tz(timezoneSelect.value);
                mLast = mLast.tz(timezoneSelect.value);
            }
            
            // Format the dates
            firstDate = mFirst.format('ddd, MMM D, YYYY');
            lastDate = mLast.format('ddd, MMM D, YYYY');
        }

        // Display date range
        if (firstDate && lastDate) {
            dateDisplay.textContent = `${firstDate} ‚Üí ${lastDate}`;
            dateDisplay.style.display = 'block';
        }

        const labels = filtered.map(d => formatTimestamp(d.timestamp));
        const data = filtered.map(d => d.players);

        let backgroundColor = 'rgba(0, 255, 157, 0.1)';
        let borderColor = '#00ff9d';
        let tension = 0.4;

        const chartType = chartTypeSelect.value;
        let fill = chartType !== 'bar';
        if (chartType === 'bar') fill = false;

        if (chart) chart.destroy();

        chart = new Chart(ctx, {
            type: chartType,
            data: {
                labels: labels,
                datasets: [{
                    label: 'Players Online',
                    data: data,
                    borderColor: borderColor,
                    backgroundColor: backgroundColor,
                    borderWidth: 2,
                    fill: fill,
                    tension: tension,
                    pointRadius: 3,
                    pointBackgroundColor: borderColor,
                    pointBorderColor: '#0a0e1a',
                    pointBorderWidth: 2,
                    pointHoverRadius: 6,
                    pointHoverBackgroundColor: '#00ff9d',
                    pointHoverBorderColor: '#fff',
                    pointHoverBorderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(10, 14, 26, 0.95)',
                        titleColor: '#00ff9d',
                        bodyColor: '#fff',
                        borderColor: '#00ff9d',
                        borderWidth: 1,
                        padding: 12,
                        titleFont: {
                            size: 13,
                            weight: 'bold',
                            family: 'Rajdhani'
                        },
                        bodyFont: {
                            size: 12,
                            family: 'Rajdhani'
                        },
                        callbacks: {
                            title: (context) => {
                                const index = context[0].dataIndex;
                                const timestamp = filtered[index].timestamp;
                                let m = moment(timestamp);
                                
                                if (timezoneSelect.value !== 'local') {
                                    m = m.tz(timezoneSelect.value);
                                }
                                
                                const format = use24HourCheckbox.checked 
                                    ? 'ddd, MMM D, YYYY - HH:mm' 
                                    : 'ddd, MMM D, YYYY - hh:mm A';
                                return m.format(format);
                            },
                            label: (context) => `Players: ${context.parsed.y.toLocaleString()}`
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { 
                            display: showGridCheckbox.checked, 
                            color: 'rgba(0, 255, 157, 0.1)' 
                        },
                        ticks: { 
                            color: '#00ff9d', 
                            font: { size: 11, family: 'Rajdhani', weight: '500' } 
                        }
                    },
                    y: {
                        grid: { 
                            display: showGridCheckbox.checked, 
                            color: 'rgba(0, 255, 157, 0.1)' 
                        },
                        ticks: { 
                            color: '#00ff9d', 
                            font: { size: 11, family: 'Rajdhani', weight: '500' } 
                        },
                        beginAtZero: true
                    }
                }
            }
        });
    }

    chartTypeSelect.addEventListener('change', () => {
        preferences.chartType = chartTypeSelect.value;
        savePreferences();
        refreshView();
    });
    
    timeRangeSelect.addEventListener('change', () => {
        preferences.timeRange = timeRangeSelect.value;
        savePreferences();
        
        // Show/hide custom range inputs
        if (timeRangeSelect.value === 'custom') {
            customRangeGroup.style.display = 'block';
        } else {
            customRangeGroup.style.display = 'none';
        }
        
        refreshView();
    });
    
    customStartDate.addEventListener('change', () => {
        preferences.customStartDate = customStartDate.value;
        savePreferences();
        refreshView();
    });
    
    customDuration.addEventListener('change', () => {
        preferences.customDuration = parseInt(customDuration.value) || 48;
        savePreferences();
        refreshView();
    });
    
    dataDensitySelect.addEventListener('change', () => {
        preferences.dataDensity = dataDensitySelect.value;
        savePreferences();
        refreshView();
    });
    
    showGridCheckbox.addEventListener('change', () => {
        preferences.showGrid = showGridCheckbox.checked;
        savePreferences();
        refreshView();
    });

    timezoneSelect.addEventListener('change', () => {
        preferences.timezone = timezoneSelect.value;
        savePreferences();
        refreshView();
    });

    use24HourCheckbox.addEventListener('change', () => {
        preferences.use24Hour = use24HourCheckbox.checked;
        savePreferences();
        refreshView();
    });

    refreshBtn.addEventListener('click', loadTrackerData);

    exportBtn.addEventListener('click', () => {
        if (!trackerData || trackerData.data.length === 0) {
            alert('No data to export');
            return;
        }
        const csv = 'Timestamp,Players\n' + trackerData.data.map(d => `${d.timestamp},${d.players}`).join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `player-tracker-${new Date().toISOString().split('T')[0]}.csv`;
        a.click();
    });

    exportImageBtn.addEventListener('click', async () => {
        if (!chart) {
            alert('Chart not available');
            return;
        }
        
        exportImageBtn.disabled = true;
        exportImageBtn.innerHTML = '<span class="btn-icon">‚è≥</span><span>EXPORTING...</span>';
        
        try {
            const canvas = await html2canvas(document.querySelector('.main'), {
                backgroundColor: '#0a0e1a',
                scale: 4,
                useCORS: true,
                allowTaint: true,
                logging: false
            });
            
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = `player-tracker-${new Date().toISOString().split('T')[0]}.png`;
            link.click();
        } catch (error) {
            console.error('Error exporting chart:', error);
            alert('Failed to export chart');
        } finally {
            exportImageBtn.disabled = false;
            exportImageBtn.innerHTML = '<span class="btn-icon">üñºÔ∏è</span><span>EXPORT PNG</span>';
        }
    });

    autoRefreshCheckbox.addEventListener('change', (e) => {
        preferences.autoRefresh = e.target.checked;
        savePreferences();
        if (e.target.checked) {
            startAutoRefresh();
        } else {
            stopAutoRefresh();
        }
    });

    function startAutoRefresh() {
        if (refreshInterval) clearInterval(refreshInterval);
        refreshInterval = setInterval(loadTrackerData, 90 * 1000);
    }

    function stopAutoRefresh() {
        if (refreshInterval) clearInterval(refreshInterval);
    }

    loadTrackerData();
    if (preferences.autoRefresh) {
        startAutoRefresh();
    }
</script>
<script type="module">
import { setRandomBackground } from './background.js';
setRandomBackground();
</script>
</body>
</html>
